

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/QQ%E5%9B%BE%E7%89%8720220422155445.jpg">
  <link rel="icon" href="/img/QQ%E5%9B%BE%E7%89%8720220422155445.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yang Qiya">
  <meta name="keywords" content="">
  
    <meta name="description" content="一文搞懂单链表的六大解题套路1 双指针21.合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的 12输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4]  思路：  两个指针各自指向list1、list2 循环遍历两个链表 判断两个大小，需要同时不为空 list1&#x3D;&#x3D;&gt;&#x3D;l&#x3D;&#x3D;ist2,把lis">
<meta property="og:type" content="article">
<meta property="og:title" content="单链表的六大解题套路">
<meta property="og:url" content="http://example.com/2022/05/04/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AD%E5%A4%A7%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/index.html">
<meta property="og:site_name" content="Qiya">
<meta property="og:description" content="一文搞懂单链表的六大解题套路1 双指针21.合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的 12输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4]  思路：  两个指针各自指向list1、list2 循环遍历两个链表 判断两个大小，需要同时不为空 list1&#x3D;&#x3D;&gt;&#x3D;l&#x3D;&#x3D;ist2,把lis">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/1.gif">
<meta property="og:image" content="https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title2.jpg">
<meta property="og:image" content="https://labuladong.gitee.io/algo/images/heap/1.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220121223837003.png">
<meta property="og:image" content="https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/2.jpeg">
<meta property="article:published_time" content="2022-05-04T07:27:49.000Z">
<meta property="article:modified_time" content="2022-05-04T01:50:48.042Z">
<meta property="article:author" content="Yang Qiya">
<meta property="article:tag" content="leetcode刷题记录">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/1.gif">
  
  
  <title>单链表的六大解题套路 - Qiya</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Qiya&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="单链表的六大解题套路">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-04 15:27" pubdate>
        May 4, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.7k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      56 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">单链表的六大解题套路</h1>
            
            <div class="markdown-body">
              <h1 id="一文搞懂单链表的六大解题套路"><a href="#一文搞懂单链表的六大解题套路" class="headerlink" title="一文搞懂单链表的六大解题套路"></a>一文搞懂单链表的六大解题套路</h1><h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1 双指针"></a>1 双指针</h2><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h3><p>将两个<strong>升序</strong>链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过<strong>拼接</strong>给定的两个链表的所有节点组成的</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>两个指针各自指向list1、list2</li>
<li>循环遍历两个链表</li>
<li>判断两个大小，需要同时不为空<ul>
<li>list1==&gt;=l==ist2,把list2赋给新的链表（<strong>虚拟新头节点</strong>）<ul>
<li>list2往后</li>
</ul>
</li>
<li>list1==&lt;==list2,把list1赋给新的链表（虚拟头节点）<ul>
<li>list1往后</li>
</ul>
</li>
<li>cur不断前进</li>
</ul>
</li>
<li>最后肯定有一个链表遍历完了，有一个还有剩余的<ul>
<li>直接把剩余的接上</li>
</ul>
</li>
</ul>
<p>有了 <code>dummy</code> 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode*p1=list1;<br>        ListNode*p2=list2;<br>        ListNode*dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<span class="hljs-comment">//放新表</span><br>        ListNode*cur=dummy;<br><br>        <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">nullptr</span>&amp;&amp;p2!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p1-&gt;val&gt;=p2-&gt;val)&#123;<br>                cur-&gt;next=p2;<br>                p2=p2-&gt;next;<br>        &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>            cur-&gt;next=p1;<br>            p1=p1-&gt;next;<br>        &#125;<br>            cur=cur-&gt;next;<br>        &#125;<br>            <span class="hljs-keyword">if</span>(p1!=<span class="hljs-literal">nullptr</span>)&#123;<br>                cur-&gt;next=p1;<span class="hljs-comment">//直接连接上p1后面的内容</span><br>        &#125;<br>            <span class="hljs-keyword">if</span>(p2!=<span class="hljs-literal">nullptr</span>)&#123;<br>                cur-&gt;next=p2;<span class="hljs-comment">//直接连接上p1后面的内容</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>错因：</p>
<ul>
<li>忘记考虑一条遍历完，剩下一条还有的情况<ul>
<li>考虑极端，一条很小，一条很大</li>
</ul>
</li>
<li>没有写while循环遍历，只写if只会走一遍</li>
<li>判断值的大小应该是：p1-&gt;val,而不是p1</li>
</ul>
<p><img src="https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/1.gif" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="23-合并-k-个有序链表"><a href="#23-合并-k-个有序链表" class="headerlink" title="23.合并 k 个有序链表"></a>23.合并 k 个有序链表</h3><p><img src="https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title2.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>难点在于，如何快速得到 <u><code>k</code> 个节点中的最小节点</u>，接到结果链表上</p>
<h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><ul>
<li><p>性质比二叉搜索树 BST 还简单</p>
</li>
<li><p>主要操作就两个：</p>
<ul>
<li><code>sink</code>（下沉）</li>
<li><code>swim</code>（上浮）</li>
</ul>
</li>
<li><p>维护二叉堆</p>
</li>
<li><p>主要应用有两个：</p>
<ul>
<li>排序方法「堆排序」</li>
<li>数据结构「优先级队列</li>
</ul>
<p>二叉堆在逻辑上其实是一种==特殊的二叉树==（完全二叉树）</p>
<ul>
<li>存储在==数组==里：<u>数组索引</u>作为“指针”</li>
<li>一般的链表二叉树：操作结点的指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 父节点的索引</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> root / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 左孩子的索引</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> root * <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// 右孩子的索引</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>arr[1]</code> 作为整棵树的根</li>
<li>arr[2]是左孩子，arr[3]是右孩子</li>
</ul>
<p><img src="https://labuladong.gitee.io/algo/images/heap/1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
</li>
</ul>
<h5 id="最大堆："><a href="#最大堆：" class="headerlink" title="最大堆："></a><strong>最大堆：</strong></h5><ul>
<li><strong>每个节点都大于等于它的两个子节点</strong></li>
<li>最上面最大</li>
</ul>
<h5 id="最小堆："><a href="#最小堆：" class="headerlink" title="最小堆："></a>最小堆：</h5><ul>
<li>每个节点都小于等于它的子节点</li>
<li>最上面最小</li>
</ul>
<h3 id="二、优先级队列"><a href="#二、优先级队列" class="headerlink" title="二、优先级队列"></a>二、优先级队列</h3><ul>
<li>插入或者删除元素的时候，元素会自动排序</li>
<li>优先级队列有两个主要 API：<ul>
<li> <code>insert</code> 插入一个元素</li>
<li><code>delMax</code>、delMin 删除最大/小元素</li>
</ul>
</li>
</ul>
<p>==把链表节点放入一个最小堆，就可以每次获得 <code>k</code> 个节点中的最小节点：==</p>
<h2 id="单链表的倒数第-k-个节点"><a href="#单链表的倒数第-k-个节点" class="headerlink" title="单链表的倒数第 k 个节点"></a>单链表的倒数第 k 个节点</h2><h3 id="寻找单链表的第-k-个节点："><a href="#寻找单链表的第-k-个节点：" class="headerlink" title="寻找单链表的第 k 个节点："></a><strong><u>寻找</u>单链表的第 <code>k</code> 个节点</strong>：</h3><ul>
<li>一个 <strong>for 循环</strong>遍历</li>
</ul>
<p>从后往前数的第 <code>k</code> 个节点：</p>
<ul>
<li>知道head、链表数n：<ul>
<li>倒数第 <code>k</code> 个节点就是正数<strong>第 <code>n - k</code> 个节点</strong></li>
<li>一个for循环</li>
</ul>
</li>
<li>知道head：<ul>
<li><strong>第一次</strong>遍历得出链表长度n</li>
<li><strong>第二次</strong>遍历找正数第n-k个结点</li>
</ul>
</li>
<li>或者：<ul>
<li><strong>双指针</strong>返回链表的<strong>倒数第 k 个节点</strong></li>
<li>p1 先走 k 步</li>
<li>p1 和 p2 同时走 n - k 步（用==p2!=null==判断是否该停止）</li>
<li>p2 现在指向第 n - k 个节点（倒数第k个）</li>
<li>这种方法==不需要考虑链表长度==，加上了虚拟头节点，也还是倒数第k个节点</li>
</ul>
</li>
</ul>
<p><strong><u>删除</u>链表的倒数第 N 个结点</strong></p>
<ul>
<li>删除倒数第 n 个，要先找倒数第 n + 1 个节点，即正数n-k-1个结点</li>
<li>又使用了==虚拟头结点==的技巧，也是为了防止出现<strong>空指针</strong>的情况（删除类考虑头节点被删除的情况）</li>
</ul>
<p><strong>调用函数法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode*dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next=head;<span class="hljs-comment">//新的头节点</span><br>        ListNode*node= <span class="hljs-built_in">findNode</span>(dummy,k+<span class="hljs-number">1</span>);<br>        node-&gt;next=node-&gt;next-&gt;next;<span class="hljs-comment">//找到后直接对这个节点操作</span><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;&#125;<br><br><span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">//找倒数第k个节点</span><br>        <span class="hljs-function">ListNode* <span class="hljs-title">findNode</span><span class="hljs-params">(ListNode*head,<span class="hljs-type">int</span> k)</span></span>&#123;<br>            ListNode*p1=head;<br>            ListNode*p2=head;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<span class="hljs-comment">//向前走k步</span><br>                p1=p1-&gt;next;<br>            &#125;    <br>            <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">nullptr</span>)&#123;<span class="hljs-comment">//同时移动</span><br>                p1=p1-&gt;next;<br>                p2=p2-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> p2;<span class="hljs-comment">//找到倒数第k个</span><br>        &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="单链表的中点"><a href="#单链表的中点" class="headerlink" title="单链表的中点"></a>单链表的中点</h2><h3 id="双指针（快慢指针）"><a href="#双指针（快慢指针）" class="headerlink" title="双指针（快慢指针）"></a>双指针（快慢指针）</h3><p>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> 走到链表末尾时，<code>slow</code> 就指向了链表中点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode*fast=head;<br>        ListNode*slow=head;<br><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;next != <span class="hljs-literal">NULL</span> )&#123;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>错因：</p>
<p>while(fast != NULL&amp;&amp;fast-&gt;next != NULL )</p>
<p>==写反了判断条件！！！==</p>
<h2 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步。</p>
<p>没有环：</p>
<ul>
<li><code>fast</code> 最终遇到空指针</li>
</ul>
<p>有环：</p>
<ul>
<li><code>fast</code> 最终和 <code>slow</code> 相遇，那肯定是 <code>fast</code> 超过了 <code>slow</code> 一圈</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode*slow=head;<br>        ListNode*fast=head;<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast==slow)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//在这里就要返回，不能到while外再返回，防止while无止境</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>错因：</p>
<p>1  while(fast!=NULL&amp;&amp;fast-&gt;next != NULL)</p>
<p>只写了：while(fast!=NULL）</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220121223837003.png" srcset="/img/loading.gif" lazyload alt="image-20220121223837003"></p>
<p>2  </p>
<p> if(fast==slow) return true; </p>
<ul>
<li><strong>必须写在while内</strong>，否则无限循环（==有环的时候，一旦相遇一次就可以停止==）</li>
<li>必须是==直接return==，否则无限循环</li>
</ul>
<p>3 true、false小写</p>
<h3 id="如何计算这个环的起点？"><a href="#如何计算这个环的起点？" class="headerlink" title="如何计算这个环的起点？"></a>如何计算这个环的起点？</h3><p>当<strong>快慢指针相遇</strong>时，让其中任一个指针指向<strong>头节点</strong>，然后让它俩<strong>以相同速度前进</strong>，<strong>再次相遇</strong>时所在的节点位置就是环开始的位置</p>
<p><img src="https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/2.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>相遇时，slow走了k步，fast走了2k步</li>
<li>整个环：<code>k</code> 的值就是环长度的「整数倍」</li>
<li>假设相遇点距环的起点的距离为 <code>m</code></li>
<li>head距离环起点：k-m</li>
<li>环中相遇点距离环起点：k-m</li>
</ul>
<h2 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h2><h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><p>思路：</p>
<ul>
<li>两个指针遍历a、b</li>
<li>有相等的值且-&gt;next也相等</li>
<li>没香蕉：一直往后便利，没有👆</li>
</ul>
<p>由于两条链表的<strong>长度可能不同</strong>，两条链表之间的<strong>节点无法对应</strong>：</p>
<p>同步前进，不能<strong>同时</strong>走到公共节点，也就无法得到相交节点 <code>c1</code></p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ul>
<li>让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code></li>
<li>就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code></li>
<li>相当于每一个都把两条链表连接，只是前后顺序不一样</li>
<li>有交点：最后面的1/几个元素分别对应</li>
<li>无交点：走到最后也是null</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode*a=headA;<br>        ListNode*b=headB;<br><br>        <span class="hljs-keyword">while</span>(a!=b)&#123;<span class="hljs-comment">//找到相等的才结束，return交点</span><br>            <span class="hljs-keyword">if</span>(a==<span class="hljs-literal">NULL</span>) a=headB;<br>            <span class="hljs-keyword">else</span> a=a-&gt;next; <span class="hljs-comment">//while里两个都移动，保证同时向右移动</span><br>            <span class="hljs-keyword">if</span>(b==<span class="hljs-literal">NULL</span>) b=headA;<br>            <span class="hljs-keyword">else</span> b=b-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode*a=headA;<br>        ListNode*b=headB;<br><br>        <span class="hljs-keyword">while</span>(a!=b)&#123;<span class="hljs-comment">//找到相等的才结束，return交点</span><br>            <span class="hljs-keyword">while</span>(a!=<span class="hljs-literal">NULL</span>&amp;&amp;a-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>                a=a-&gt;next;<br>            &#125;<br>            a=headB;<span class="hljs-comment">//a连接b</span><br>            <span class="hljs-keyword">while</span>(a!=<span class="hljs-literal">NULL</span>&amp;&amp;a-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>                a=a-&gt;next;<span class="hljs-comment">//遍历B</span><br>            &#125;<br><br>             <span class="hljs-keyword">while</span>(b!=<span class="hljs-literal">NULL</span>&amp;&amp;b-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>                b=b-&gt;next;<br>            &#125;<br>            b=headA;<span class="hljs-comment">//b连接a</span><br>            <span class="hljs-keyword">while</span>(b!=<span class="hljs-literal">NULL</span>&amp;&amp;b-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>                b=b-&gt;next;<span class="hljs-comment">//遍历A</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>👆while里面并列while，a先移动完再移动b，无法同步移动</p>
<blockquote>
<p>(a+b).length = (b+a).length</p>
</blockquote>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>分别统计<strong>两条链表的长度</strong>，差值表示<strong>非公共部分的长度差</strong>，那么让长链表的指针<strong>先走差值的步数</strong>，再<strong>齐头并进</strong>，那么如果两个指针相等则是相交的位置</p>
<ul>
<li>for计算长度</li>
<li>重新指向头</li>
<li>长的那个走长度差步数</li>
<li>再同步前进直到遇到相等的<ul>
<li>都为null</li>
<li>相交了</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode*a=headA;<br>        ListNode*b=headB;<br>        <span class="hljs-type">int</span> len_a=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len_b=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(a=headA;a!=<span class="hljs-literal">NULL</span>;len_a++)&#123;<br>            a=a-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(b=headB;b!=<span class="hljs-literal">NULL</span>;len_b++)&#123;<br>            b=b-&gt;next;<br>        &#125;<br><br>        a=headA;<br>        b=headB;<br><br>        <span class="hljs-keyword">if</span>(len_a&gt;len_b)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len_a-len_b;i++)&#123;<br>                a=a-&gt;next;<span class="hljs-comment">//a先走</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len_b-len_a;i++)&#123;<br>                b=b-&gt;next;<span class="hljs-comment">//a先走</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//同步前进</span><br>        <span class="hljs-keyword">while</span>(a!=b)&#123;<br>            a=a-&gt;next;<br>            b=b-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
























            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">leetcode刷题记录</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/04/lbld-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">lbld-滑动窗口</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/04/%E5%93%88%E5%B8%8C%E8%A1%A8Hash%20table/">
                        <span class="hidden-mobile">哈希表Hash table</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
